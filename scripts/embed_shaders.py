#!/usr/bin/env python3
"""
Script to generate embedded shader code from WGSL files for web builds.
This script converts .wgsl files into C++ header file with embedded strings.
"""

import os
import sys
import hashlib
import time
from pathlib import Path

def escape_string(content):
    """Escape string content for C++ raw string literal."""
    # Use raw string literal with delimiter to avoid most escaping issues
    delimiter = "SHADER"
    # Make sure our delimiter doesn't appear in the content
    counter = 0
    while delimiter in content:
        counter += 1
        delimiter = f"SHADER{counter}"

    return f'R"{delimiter}(\n{content}\n){delimiter}"'

def get_file_hash(filepath):
    """Get MD5 hash of file for change detection."""
    try:
        with open(filepath, 'rb') as f:
            return hashlib.md5(f.read()).hexdigest()
    except Exception:
        return ""

def should_regenerate(shader_dir, output_file):
    """Check if we need to regenerate the embedded shaders."""
    if not os.path.exists(output_file):
        return True
    
    output_mtime = os.path.getmtime(output_file)
    
    # Check if any shader file is newer than output
    for root, _, files in os.walk(shader_dir):
        for file in files:
            if file.endswith('.wgsl'):
                shader_path = os.path.join(root, file)
                if os.path.getmtime(shader_path) > output_mtime:
                    return True
    
    return False

def generate_shader_map(shader_dir, output_file):
    """Generate C++ header file with embedded shaders."""
    
    # Check if regeneration is needed
    if not should_regenerate(shader_dir, output_file):
        print(f"Embedded shaders are up to date: {output_file}")
        return

    shader_files = []
    total_size = 0

    # Find all .wgsl files recursively
    for root, _, files in os.walk(shader_dir):
        for file in files:
            if file.endswith('.wgsl'):
                full_path = os.path.join(root, file)
                # Get relative path from shader_dir
                rel_path = os.path.relpath(full_path, shader_dir)
                # Convert Windows path separators to forward slashes
                rel_path = rel_path.replace('\\', '/')
                
                # Get file size
                try:
                    size = os.path.getsize(full_path)
                    total_size += size
                    shader_files.append((rel_path, full_path, size))
                except Exception as e:
                    print(f"Warning: Could not get size for {full_path}: {e}")
                    shader_files.append((rel_path, full_path, 0))

    if not shader_files:
        print(f"No .wgsl files found in {shader_dir}")
        return

    print(f"Found {len(shader_files)} shader files ({total_size} bytes total)")

    # Generate header content
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    header_content = f'''// Auto-generated embedded shaders
// DO NOT EDIT - This file is generated by scripts/embed_shaders.py
// Generated on: {timestamp}
// Total size: {total_size} bytes

#pragma once
#include <string>
#include <unordered_map>

namespace EmbeddedShaders {{

// Embedded shader code
'''

    # Add each shader as a string constant
    for rel_path, full_path, size in shader_files:
        try:
            with open(full_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Create valid C++ identifier from path
            var_name = rel_path.replace('/', '_').replace('.', '_').replace('-', '_')

            header_content += f'''
// {rel_path} ({size} bytes)
const std::string {var_name} = {escape_string(content)};
'''
        except Exception as e:
            print(f"Error reading {full_path}: {e}")
            continue

    # Add the shader map
    header_content += '''
// Shader path to content mapping
const std::unordered_map<std::string, std::string> shaderMap = {
'''

    for rel_path, full_path, size in shader_files:
        var_name = rel_path.replace('/', '_').replace('.', '_').replace('-', '_')
        header_content += f'    {{"{rel_path}", {var_name}}},\n'

    header_content += '''};

// Function to get shader by path
inline const std::string& getShader(const std::string& path) {
    auto it = shaderMap.find(path);
    if (it != shaderMap.end()) {
        return it->second;
    }
    static const std::string empty;
    return empty;
}

// Get number of embedded shaders
inline size_t getShaderCount() {
    return shaderMap.size();
}

// Get total embedded size
inline size_t getTotalSize() {
    return ''' + str(total_size) + ''';
}

} // namespace EmbeddedShaders
'''

    # Write to output file
    try:
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(header_content)

        print(f"Generated embedded shaders: {output_file}")
        print(f"Embedded {len(shader_files)} shader files ({total_size} bytes total):")
        for rel_path, _, size in shader_files:
            print(f"  - {rel_path} ({size} bytes)")

    except Exception as e:
        print(f"Error writing {output_file}: {e}")
        sys.exit(1)

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 embed_shaders.py <shader_dir> <output_header>")
        print("Example: python3 embed_shaders.py shaders/ engine/rendering/EmbeddedShaders.h")
        sys.exit(1)

    shader_dir = sys.argv[1]
    output_file = sys.argv[2]

    if not os.path.isdir(shader_dir):
        print(f"Error: Shader directory '{shader_dir}' not found")
        sys.exit(1)

    generate_shader_map(shader_dir, output_file)

if __name__ == "__main__":
    main()